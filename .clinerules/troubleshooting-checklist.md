# チャット機能のトラブルシューティング振り返りと開発チェックリスト

## 対応の流れ（エンドポイントパス不一致問題）

1. **問題の発見**
   - チャット機能が動作せず、「戦略とは」という質問に対して応答がない状態を確認

2. **フロントエンド側の調査**
   - Chat.tsxファイルを確認し、UIの実装に問題がないことを確認
   - useChat.tsフックを確認し、APIエンドポイントのパスに問題があることを発見
   - ストリーミングモードでは `/api/chat` を使用していたが、非ストリーミングモードでは単に `/chat` を使用していた

3. **バックエンド側の調査**
   - バックエンドサーバー（FastAPI）が起動しているか確認
   - バックエンドサーバーが停止していることを発見
   - main.pyファイルを確認し、APIエンドポイントが `/api/chat` として定義されていることを確認

4. **修正作業**
   - バックエンドサーバーを再起動
   - フロントエンドのuseChat.tsファイルを修正し、非ストリーミングモードでも `/api/chat` を使用するように変更
   - フロントエンドサーバーを再起動

5. **検証**
   - curlコマンドでAPIエンドポイントを直接テストし、正常に動作することを確認
   - 「戦略とは」という質問に対して適切な回答が返されることを確認

## 対応の流れ（レスポンス形式の不一致問題）

1. **問題の発見**
   - チャット機能でAPIリクエストを送信すると、JSONパースエラーが発生
   - エラーメッセージ: `SyntaxError: Unexpected token 'そ', "その情報はハイライトにありません。" is not valid JSON`

2. **フロントエンド側の調査**
   - Chat.tsxとuseChat.tsのAPIリクエスト処理を確認
   - レスポンスをJSON形式として処理していることを確認

3. **バックエンド側の調査**
   - バックエンドAPIが返すレスポンスがプレーンテキスト形式であることを確認
   - Content-Typeヘッダーがtext/plainであることを確認

4. **修正作業**
   - フロントエンドのレスポンス処理を修正
   - Content-Typeヘッダーをチェックし、JSONまたはプレーンテキストとして適切に処理するよう変更
   - エラーハンドリングを改善

5. **検証**
   - APIテスト機能を実装してリクエスト/レスポンスを確認
   - プレーンテキストレスポンスが正しく処理されることを確認

## 今後の開発におけるチェックリスト

### 開発環境セットアップ時

- [ ] **サーバー起動スクリプトの確認**
  - `run_dev.sh`などの起動スクリプトが正しく設定されているか確認
  - バックエンドとフロントエンドの両方が起動されるか確認

- [ ] **環境変数の確認**
  - `.env`ファイルが正しく設定されているか確認
  - 開発環境と本番環境の設定が適切に分離されているか確認

- [ ] **ポート設定の確認**
  - バックエンド（8000）とフロントエンド（5173）のポート番号が正しく設定されているか確認
  - ポート番号の衝突がないか確認

### APIエンドポイント実装時

- [ ] **エンドポイントパスの統一**
  - バックエンドとフロントエンドでエンドポイントパスが一致しているか確認
  - プレフィックス（`/api/`など）の使用が一貫しているか確認

- [ ] **認証トークンの確認**
  - 開発環境用のトークン（`dev-token-123`など）が正しく設定されているか確認
  - 認証ヘッダーが正しく送信されているか確認

- [ ] **リクエスト/レスポンス形式の確認**
  - リクエストボディの形式が正しいか確認
  - レスポンスの形式がフロントエンドの期待と一致しているか確認

- [ ] **レスポンス形式の一貫性確認**
  - バックエンドが返すレスポンス形式（JSON/プレーンテキスト）を明確に定義
  - Content-Typeヘッダーが適切に設定されているか確認
  - フロントエンドがすべての可能なレスポンス形式を処理できるか確認

### デバッグ時

- [ ] **サーバー状態の確認**
  - バックエンドサーバーが起動しているか確認
  - フロントエンドサーバーが起動しているか確認
  - 必要に応じて再起動を行う

- [ ] **ログの確認**
  - バックエンドのログでエラーメッセージを確認
  - フロントエンドのコンソールログでエラーメッセージを確認
  - ネットワークリクエストのログを確認

- [ ] **直接APIテスト**
  - curlやPostmanなどのツールでAPIを直接テスト
  - リクエストとレスポンスを確認

- [ ] **レスポンスヘッダーの確認**
  - Content-Typeヘッダーを確認し、期待される形式と一致しているか確認
  - ブラウザの開発者ツールのネットワークタブでレスポンスの詳細を確認
  
- [ ] **シンプルなテストケースの作成**
  - 複雑な機能から切り離した単純なAPIリクエストテストを実装
  - 直接fetchやaxiosを使用したテストコードを作成

### コード変更時

- [ ] **APIパスの一貫性確認**
  - フロントエンドのAPI呼び出しパスがバックエンドの定義と一致しているか確認
  - 環境変数やベースURLの使用が正しいか確認

- [ ] **エラーハンドリングの確認**
  - エラー時の処理が適切に実装されているか確認
  - ユーザーに適切なエラーメッセージが表示されるか確認

- [ ] **変更の影響範囲確認**
  - 変更が他の機能に影響を与えていないか確認
  - 関連するコンポーネントやフックも確認

- [ ] **レスポンス処理の柔軟性確認**
  - 異なる形式のレスポンス（JSON/プレーンテキスト）を適切に処理できるか確認
  - Content-Typeヘッダーに基づいた条件分岐が実装されているか確認

## 教訓

1. **サーバー状態の確認を最初に行う**
   - APIリクエストが失敗する場合、まずサーバーが起動しているか確認する
   - エラーメッセージだけでなく、サーバーのログも確認する

2. **エンドポイントパスの一貫性を保つ**
   - バックエンドとフロントエンドでエンドポイントパスを一致させる
   - プレフィックス（`/api/`など）の使用を統一する

3. **段階的なデバッグを行う**
   - フロントエンドとバックエンドを分離してテストする
   - curlなどのツールでAPIを直接テストする

4. **ログの活用**
   - 詳細なログを出力するように設定する
   - エラー発生時にはログを確認する習慣をつける

5. **レスポンス形式の柔軟な処理**
   - Content-Typeヘッダーを確認し、適切なレスポンス処理を行う
   - JSONとプレーンテキストの両方に対応できるようにする
   - axiosやfetchの自動変換機能に過度に依存しない

6. **詳細なエラーログの実装**
   - エラーオブジェクトの詳細情報（名前、メッセージ、スタックトレース）をログに出力
   - try-catchブロックを適切に配置し、エラーを見逃さない

7. **シンプルなテストケースの活用**
   - 複雑な機能から切り離した単純なテストコードを作成
   - 問題の切り分けと特定を容易にする

これらのチェックリストと教訓を開発プロセスに組み込むことで、同様の問題の早期発見と解決が可能になります。
